<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=zh-cn lang=zh-cn><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.68.3"><meta name=viewport content="width=device-width,initial-scale=1"><title>golang 的 interface(第一篇) - 接口的定义与实现 &#183; Chyroc的博客</title><meta name=description content><link type=text/css rel=stylesheet href=https://chyroc.cn/css/print.css media=print><link type=text/css rel=stylesheet href=https://chyroc.cn/css/poole.css><link type=text/css rel=stylesheet href=https://chyroc.cn/css/syntax.css><link type=text/css rel=stylesheet href=https://chyroc.cn/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body class=theme-base-08><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://chyroc.cn><h1>Chyroc的博客</h1></a><p class=lead></p></div><nav><ul class=sidebar-nav><li><a href=https://chyroc.cn>Home</a></li><li><a href=/>主页</a></li><li><a href=/blogroll/>友链</a></li><li><a href=/about/>关于</a></li></ul></nav></div></aside><main class="content container"><div class=post><h1>golang 的 interface(第一篇) - 接口的定义与实现</h1><time datetime=2017-08-03T16:40:48+0800 class=post-date>2017-08-03 16:40:48</time><h2 id=golang-有哪些数据类型>golang 有哪些数据类型</h2><p>interface 是一种数据类型吗，答案是：是。</p><p>golang 语言有四种数据类型，分别是</p><ul><li>基本类型(basic)<ul><li>数字</li><li>字符串</li><li>布尔型</li></ul></li><li>聚合类型(aggregate)<ul><li><strong>数组</strong></li><li>struct</li></ul></li><li>复合类型(reference)<ul><li>指针</li><li><strong>slice</strong></li><li>map</li><li>函数</li><li>channel</li></ul></li><li>接口类型(interface)</li></ul><h2 id=什么是方法>什么是方法</h2><p>方法是定义在一个数据类型上面的函数，可以类比为 “面向对象中，类中的方法”。</p><p>方法和这个数据类型需要处于同一个包里，所以对于内置类型，如 int，需要从他定义一个数据类型，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CountNum</span> <span style=color:#66d9ef>int</span>
</code></pre></div><p>然后再在这个新的数据类型上定义方法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>CountNum</span>) <span style=color:#a6e22e>Print</span> {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;CountNum is %d&#34;</span>, <span style=color:#a6e22e>i</span>)
}
</code></pre></div><p>最常用的就是在 struct 上定义方法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>Age</span> <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#a6e22e>Person</span>) <span style=color:#a6e22e>Get</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;Person name: %6s, age: %4d&#34;</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Age</span>)
}
</code></pre></div><p>使用方法修改所定义的数据类型的数据</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#a6e22e>Person</span>) <span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) {
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#a6e22e>name</span>
}
</code></pre></div><p>如果直接这么写，是有问题的。</p><p>因为在 golang 中是参数是值传递，所以在上面这个方法里，收到了类型为<code>Person</code>的一个值的拷贝<code>p</code>，然后对<code>p</code>做了修改，是无法传递出去的。</p><p>所以需要改为传递指针变量：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Person</span>) <span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) {
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#a6e22e>name</span>
}
</code></pre></div><p>这样就可以通过指针修改原来的数据。</p><p>事实上，指针仍然是值传递，但是，哈哈，拷贝的指针指向的地方是不变的，是依然可以修改的。</p><h2 id=怎么定义一个-interface>怎么定义一个 interface</h2><p>划重点：<strong>接口的定义是方法的声明的集合，接口的实现是方法的实现的集合</strong></p><p>所以我刚刚先说了方法。</p><p>和方法不一样的是，接口并不是定义在具体的类型上面的（方法是这样的）。</p><p>同一个接口可以在不同数据类型上实现，取决于你想要怎么搞了。</p><p>这里我先定义一个接口：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>GetSet</span> <span style=color:#66d9ef>interface</span> {
    <span style=color:#a6e22e>Get</span>() <span style=color:#66d9ef>string</span>
    <span style=color:#a6e22e>Set</span>(<span style=color:#66d9ef>string</span>)
}
</code></pre></div><p>这个接口声明了两个方法：<code>Get() string</code>,<code>Set(string)</code>，这两个方法合起来(<code>interface{ }</code>)就构成了一个接口，这个接口的名字叫做<code>GetSet</code>。</p><h2 id=怎么实现一个-interface>怎么实现一个 interface</h2><h4 id=说明>说明</h4><p>golang 这门语言的接口与其他语言的不同之处在于，golang 的接口是<code>隐式实现</code>的。</p><p>这是什么意思呢？</p><p>意思就是你不需要<code>显式</code>的这么做：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SomeClass</span> <span style=color:#66d9ef>implements</span> SomeInterface <span style=color:#f92672>{</span>

<span style=color:#f92672>}</span>
</code></pre></div><h4 id=那怎么做>那怎么做</h4><p>刚刚说了：「接口的实现是方法的实现的集合」，方法是定义在数据类型上面的，所以先给出一个数据类型：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int</span>
}
</code></pre></div><p>然后对这个数据类型实现接口定义里面所有声明的方法，也就是：<code>Get() string</code>,<code>Set(string)</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Person</span>) <span style=color:#a6e22e>Get</span>() <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;Person name: %6s, age: %4d&#34;</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Age</span>)
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Person</span>) <span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) {
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#a6e22e>name</span>
}
</code></pre></div><h4 id=断言是否实现了接口>断言是否实现了接口</h4><p>ok，到这里为止，我定义了一个接口<code>GetSet</code>，然后用<code>Person</code>实现了这个接口，一切都很美好，问题是，我真的实现了这个接口了吗？</p><p>有一个简单的方法去判断：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_</span> <span style=color:#a6e22e>GetSet</span> = new(<span style=color:#a6e22e>Person</span>) <span style=color:#75715e>// var _ GetSet = Person{}
</span></code></pre></div><p>这是一个断言：<code>Person</code>的一个值实现了接口<code>GetSet</code>，如果<code>Person</code>没有实现了接口<code>GetSet</code>，编译的时候就会报错。</p><p>实际上，我们不需要创建一个变量（<code>new(Person)</code>），因为<code>Person</code>是任意值都实现了这个接口，所以<code>nil</code>也实现了，所以可以用类型转化做断言，代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_</span> <span style=color:#a6e22e>GetSet</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Person</span>)(<span style=color:#66d9ef>nil</span>)
</code></pre></div><h2 id=空-interface-是什么>空 interface 是什么</h2><p>什么是空接口：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>interface</span>{}
</code></pre></div><p>上面说过，接口是声明的方法的集合，空接口没有声明方法，所以任何类型都实现了空接口。</p><p>所以一个函数可以使用<code>interface{}</code>接受任意类型的值作为参数，也可以使用<code>interface{}</code>将任意类型的值作为返回值。</p></div><script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src=../../js/jquery-3.3.1.min.js></script><script src=../../js/code.js></script><script src=../../css/highlight.css></script><script src=../../js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init();</script><script>hljs.configure({languages:[]});hljs.initHighlightingOnLoad();</script><hr>© <a href=https://chyroc.cn>chyroc</a> <a href=https://github.com/spf13/hyde>Theme By hyde</a> 2020
<span id=reading-statistics><span><div id=git-comments></div><link rel=stylesheet href=https://imsun.github.io/gitment/style/default.css><script src=https://imsun.github.io/gitment/dist/gitment.browser.js></script><script>var gitment=new Gitment({id:'golang-interface-i',title:'golang 的 interface(第一篇) - 接口的定义与实现',owner:'chyroc',repo:'blog',oauth:{client_id:'36628d87f0ace3c0f34c',client_secret:'814e29f878a31ddf2a0f8f010c2bc3615750a998',}})
gitment.render('git-comments')</script></main></body></html>